package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/kluzzebass/gqlt/internal/mockserver/graph/model"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.User, error) {
	role := model.UserRoleUser
	if input.Role != nil {
		role = *input.Role
	}
	user := r.store.CreateUser(input.Name, input.Email, role, input.Website)
	r.store.BroadcastUserEvent(user)
	return user, nil
}

// CreateTodo is the resolver for the createTodo field.
func (r *mutationResolver) CreateTodo(ctx context.Context, input model.CreateTodoInput) (*model.Todo, error) {
	// For simplicity, use first user as creator
	todo := r.store.CreateTodo(input.Title, "User:1", &input)
	r.store.BroadcastTodoEvent(todo)
	return todo, nil
}

// UpdateTodo is the resolver for the updateTodo field.
func (r *mutationResolver) UpdateTodo(ctx context.Context, input model.UpdateTodoInput) (*model.Todo, error) {
	todo, err := r.store.UpdateTodo(input.ID, &input)
	if err == nil && todo != nil {
		r.store.BroadcastTodoEvent(todo)
	}
	return todo, err
}

// DeleteTodo is the resolver for the deleteTodo field.
func (r *mutationResolver) DeleteTodo(ctx context.Context, id string) (bool, error) {
	return r.store.DeleteTodo(id), nil
}

// CompleteTodo is the resolver for the completeTodo field.
func (r *mutationResolver) CompleteTodo(ctx context.Context, id string) (*model.Todo, error) {
	completed := model.TodoStatusCompleted
	updateInput := &model.UpdateTodoInput{
		ID:     id,
		Status: &completed,
	}
	todo, err := r.store.UpdateTodo(id, updateInput)
	if err == nil && todo != nil {
		r.store.BroadcastTodoEvent(todo)
	}
	return todo, err
}

// AddFileAttachment is the resolver for the addFileAttachment field.
func (r *mutationResolver) AddFileAttachment(ctx context.Context, todoID string, title string, file graphql.Upload) (*model.FileAttachment, error) {
	attachment := r.store.CreateFileAttachment(title, file.Filename, file.ContentType, int(file.Size))
	r.store.AddAttachmentToTodo(todoID, attachment.ID)
	return attachment, nil
}

// AddLinkAttachment is the resolver for the addLinkAttachment field.
func (r *mutationResolver) AddLinkAttachment(ctx context.Context, todoID string, title string, url string, description *string) (*model.LinkAttachment, error) {
	attachment := r.store.CreateLinkAttachment(title, url, description)
	r.store.AddAttachmentToTodo(todoID, attachment.ID)
	return attachment, nil
}

// RemoveAttachment is the resolver for the removeAttachment field.
func (r *mutationResolver) RemoveAttachment(ctx context.Context, todoID string, attachmentID string) (bool, error) {
	return r.store.RemoveAttachmentFromTodo(todoID, attachmentID), nil
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id string) (model.Node, error) {
	// Parse global ID format "TypeName:localId"
	parts := strings.Split(id, ":")
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid node ID format: %s", id)
	}

	typeName := parts[0]

	// Route to correct store based on type
	switch typeName {
	case "User":
		return r.store.GetUser(id)
	case "Todo":
		return r.store.GetTodo(id)
	case "FileAttachment":
		return r.store.GetFileAttachment(id)
	case "LinkAttachment":
		return r.store.GetLinkAttachment(id)
	default:
		return nil, fmt.Errorf("unknown node type: %s", typeName)
	}
}

// Hello is the resolver for the hello field.
func (r *queryResolver) Hello(ctx context.Context) (string, error) {
	return "Hello, GraphQL!", nil
}

// Echo is the resolver for the echo field.
func (r *queryResolver) Echo(ctx context.Context, message string) (string, error) {
	return message, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	return r.store.GetUser(id)
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int32, offset *int32) ([]*model.User, error) {
	users := r.store.GetUsers()

	// Apply offset
	start := 0
	if offset != nil && *offset > 0 {
		start = int(*offset)
		if start >= len(users) {
			return []*model.User{}, nil
		}
	}

	// Apply limit
	end := len(users)
	if limit != nil && *limit > 0 {
		end = start + int(*limit)
		if end > len(users) {
			end = len(users)
		}
	}

	return users[start:end], nil
}

// Todo is the resolver for the todo field.
func (r *queryResolver) Todo(ctx context.Context, id string) (*model.Todo, error) {
	return r.store.GetTodo(id)
}

// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context, filters *model.TodoFilters, limit *int32, offset *int32) ([]*model.Todo, error) {
	allTodos := r.store.GetTodos()

	// Apply filters if provided
	var filteredTodos []*model.Todo
	if filters != nil {
		for _, todo := range allTodos {
			match := true

			if filters.Status != nil && todo.Status != *filters.Status {
				match = false
			}
			if filters.Priority != nil && todo.Priority != *filters.Priority {
				match = false
			}
			if filters.AssignedToID != nil && (todo.AssignedTo == nil || todo.AssignedTo.ID != *filters.AssignedToID) {
				match = false
			}
			if filters.CreatedByID != nil && todo.CreatedBy.ID != *filters.CreatedByID {
				match = false
			}
			if filters.Tag != nil {
				tagMatch := false
				for _, tag := range todo.Tags {
					if tag == *filters.Tag {
						tagMatch = true
						break
					}
				}
				if !tagMatch {
					match = false
				}
			}

			if match {
				filteredTodos = append(filteredTodos, todo)
			}
		}
	} else {
		filteredTodos = allTodos
	}

	// Apply offset
	start := 0
	if offset != nil && *offset > 0 {
		start = int(*offset)
		if start >= len(filteredTodos) {
			return []*model.Todo{}, nil
		}
	}

	// Apply limit
	end := len(filteredTodos)
	if limit != nil && *limit > 0 {
		end = start + int(*limit)
		if end > len(filteredTodos) {
			end = len(filteredTodos)
		}
	}

	return filteredTodos[start:end], nil
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, term string, limit *int32) ([]model.SearchResult, error) {
	var results []model.SearchResult
	lowerTerm := strings.ToLower(term)

	// Search users
	for _, user := range r.store.GetUsers() {
		if strings.Contains(strings.ToLower(user.Name), lowerTerm) ||
			strings.Contains(strings.ToLower(user.Email), lowerTerm) {
			results = append(results, user)
		}
	}

	// Search todos
	for _, todo := range r.store.GetTodos() {
		if strings.Contains(strings.ToLower(todo.Title), lowerTerm) ||
			(todo.Notes != nil && strings.Contains(strings.ToLower(*todo.Notes), lowerTerm)) {
			results = append(results, todo)
		}
	}

	// Apply limit
	maxResults := len(results)
	if limit != nil && *limit > 0 && int(*limit) < maxResults {
		maxResults = int(*limit)
	}

	return results[:maxResults], nil
}

// CurrentTime is the resolver for the currentTime field.
func (r *queryResolver) CurrentTime(ctx context.Context) (*time.Time, error) {
	now := time.Now()
	return &now, nil
}

// Version is the resolver for the version field.
func (r *queryResolver) Version(ctx context.Context) (string, error) {
	return "1.0.0", nil
}

// Counter is the resolver for the counter field.
func (r *subscriptionResolver) Counter(ctx context.Context) (<-chan int32, error) {
	ch := make(chan int32)
	go func() {
		defer close(ch)
		var counter int32 = 0
		ticker := time.NewTicker(1 * time.Second)
		defer ticker.Stop()
		for {
			select {
			case <-ctx.Done():
				return
			case <-ticker.C:
				counter++
				select {
				case ch <- counter:
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return ch, nil
}

// TodoEvents is the resolver for the todoEvents field.
func (r *subscriptionResolver) TodoEvents(ctx context.Context) (<-chan *model.Todo, error) {
	// Create a buffered channel for receiving events from the store
	eventCh := make(chan *model.Todo, 10)

	// Register this subscription with the store
	subID := r.store.SubscribeToTodoEvents(eventCh)

	// Create the response channel
	ch := make(chan *model.Todo)

	go func() {
		defer close(ch)
		defer r.store.UnsubscribeFromTodoEvents(subID)

		for {
			select {
			case <-ctx.Done():
				// Client disconnected, clean up
				return

			case todo, ok := <-eventCh:
				if !ok {
					// Event channel closed, stop subscription
					return
				}
				// Forward the event to the client
				select {
				case ch <- todo:
					// Event sent successfully
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	return ch, nil
}

// Tick is the resolver for the tick field.
func (r *subscriptionResolver) Tick(ctx context.Context, interval *int32) (<-chan *time.Time, error) {
	ch := make(chan *time.Time)
	// Default to 1 second if interval is not provided
	intervalSeconds := 1
	if interval != nil && *interval > 0 {
		intervalSeconds = int(*interval)
	}
	go func() {
		defer close(ch)
		ticker := time.NewTicker(time.Duration(intervalSeconds) * time.Second)
		defer ticker.Stop()
		for {
			select {
			case <-ctx.Done():
				return
			case t := <-ticker.C:
				select {
				case ch <- &t:
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return ch, nil
}

// UserEvents is the resolver for the userEvents field.
func (r *subscriptionResolver) UserEvents(ctx context.Context) (<-chan *model.User, error) {
	// Create a buffered channel for receiving events from the store
	eventCh := make(chan *model.User, 10)

	// Register this subscription with the store
	subID := r.store.SubscribeToUserEvents(eventCh)

	// Create the response channel
	ch := make(chan *model.User)

	go func() {
		defer close(ch)
		defer r.store.UnsubscribeFromUserEvents(subID)

		for {
			select {
			case <-ctx.Done():
				// Client disconnected, clean up
				return

			case user, ok := <-eventCh:
				if !ok {
					// Event channel closed, stop subscription
					return
				}
				// Forward the event to the client
				select {
				case ch <- user:
					// Event sent successfully
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
