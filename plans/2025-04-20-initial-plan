================================================================
IMPLEMENTATION PLAN — GraphQL CLI Tool (gqlt)
Language: Go
Goal: Minimal, composable command‑line client for running GraphQL ops

CURRENT APPROACH: Using native HTTP client instead of GraphQL libraries
- Full control over request/response handling
- Native operation name support
- Authentication via standard HTTP headers
- No external GraphQL library dependencies
- Minimal dependencies (just cobra and color)
================================================================

---------------------------------------------------------------
PHASE 1 | PROJECT INITIALIZATION
---------------------------------------------------------------

[x] 1. Initialize "gqlt"
    go mod init github.com/kluzzebass/gqlt

[x] 2. Add module dependencies
    go get github.com/spf13/cobra@latest
    go get github.com/fatih/color@latest (optional pretty output)
    Note: Using native HTTP client instead of GraphQL library for full control
    Note: Authentication handled via headers, no OAuth2 library needed

[x] 3. Base layout
    /cmd
      root.go
      run.go
      introspect.go
      describe.go
      test.go
      schema_diff.go
    /internal
      /config
      /io
      /output
    /main.go

[x] 4. main.go content:
    package main
    import "github.com/kluzzebass/gqlt/cmd"
    func main() { cmd.Execute() }

[x] 5. cmd/root.go
    Define the root Cobra command "gqlt"
    Version: 0.1.x
    PersistentFlags: (e.g. global --config)
    Example:
      var rootCmd = &cobra.Command{Use: "gqlt"}
      func Execute() { cobra.CheckErr(rootCmd.Execute()) }

---------------------------------------------------------------
PHASE 2 | RUN COMMAND (core)
---------------------------------------------------------------

Purpose: Execute GraphQL operation (query or mutation)

[x] 6. cmd/run.go
    Use: "run"
    Short: "Execute a GraphQL operation against an endpoint"

[x] 7. Define flags with short options:
    -u, --url string                 (GraphQL endpoint; required if not in config)
    -q, --query string               (inline GraphQL document)
    -Q, --query-file string          (path to .graphql file)
    -o, --operation string           (operationName)
    -v, --vars string                (JSON object)
    -V, --vars-file string           (path to JSON file)
    -H, --header key=value           (repeatable)
    -f, --file name=path             (file uploads; repeatable)
    -F, --files-list string          (file containing list of files to upload)
    -c, --config path                (optional; override default)
    -O, --out json|pretty|raw        (output mode: json=formatted, pretty=colored, raw=compact; default json)
    -U, --username string            (username for basic authentication)
    -p, --password string            (password for basic authentication)
    Note: Bearer tokens handled via -H "Authorization: Bearer <token>"

[x] 8. Input validation rules:
    - if both --query and --query-file => error
    - if neither => read full stdin as query
    - if both --vars and --vars-file => error
    - headers accumulate across occurrences
    - files accumulate across occurrences
    - if --config given, merge config values before network call

[x] 9. Implement helper resolution:

    // loadQuery: returns string
    if runFlags.query != "" return runFlags.query
    else if runFlags.queryFile != "" => read file
    else => read stdin until EOF

    // loadVars: returns map[string]interface{}
    if --vars => json.Unmarshal
    if --vars-file => read + Unmarshal
    else => empty map

    // parseHeaders: split by first '='
    result[k] = v for each --header occurrence

    // parseFiles: map[name] = path for each --file occurrence

[x] 10. Run GraphQL call using native HTTP client:
    - Build GraphQL payload with query, operationName, variables
    - Create HTTP POST request to GraphQL endpoint
    - Set Content-Type: application/json
    - Add custom headers
    - Execute request with authenticated HTTP client
    - Parse JSON response into map[string]interface{}

[x] 11. Error handling:
    if err != nil => print to stderr, exit 1
    if result["errors"] exists and non-empty => exit 2

[x] 12. Output handler:
    switch outMode:
      "json": formatted JSON with indentation (default)
      "pretty": colorized formatted JSON with syntax highlighting
      "raw": unformatted JSON (no indentation, compact)

---------------------------------------------------------------
PHASE 3 | CONFIG FILES
---------------------------------------------------------------

Config location search order:
1. --config flag
2. ./.gqlt/config.json
3. $HOME/.config/gqlt/config.json

[ ] 13. internal/config/config.go:
    type Config struct {
        Current   string                    `json:"current"`   // active config name (defaults to "default")
        Configs   map[string]ConfigEntry    `json:"configs"`   // named configurations
    }
    
    type ConfigEntry struct {
        Endpoint string            `json:"endpoint"`
        Headers  map[string]string `json:"headers"`
        Defaults struct {
            Out string `json:"out"`
        } `json:"defaults"`
    }
    
    // Default configuration is always available and used when:
    // - No config file exists
    // - Current config doesn't exist
    // - No specific config is specified

[ ] 14. Load(path):
    reads JSON, returns *Config
    if path empty => search in standard paths
    fallback = nil if not found

[ ] 15. Merge(cli *Config, cfg *Config):
    - CLI values override
    - headers merge (CLI overwrites)
    - default Out fallback from cfg if not set
    return merged *Config

[ ] 16. cmd/config.go (optional)
    subcommands:
      gqlt config show [name]           (show current or named config)
      gqlt config list                  (list all configurations)
      gqlt config set <name> <key> <value>  (set value in named config)
      gqlt config use <name>           (switch to named config)
      gqlt config create <name>         (create new named config)
      gqlt config delete <name>         (delete named config)
      gqlt config clear [name]          (clear current or named config)
      gqlt config init                  (create default config file)
      
      # AI-friendly commands
      gqlt config describe              (show schema and examples)
      gqlt config validate              (check config file syntax)
      gqlt config examples              (show usage examples)
      gqlt config help                  (detailed help with examples)
      gqlt config template <name>       (create from template)
      gqlt config docs                  (generate markdown docs)
      
    reads/updates JSON file on disk
    
    Note: "default" config is always available and used as fallback

[ ] 17. Example config file structure (AI-friendly):
    {
      "current": "production",
      "configs": {
        "default": {
          "endpoint": "https://api.example.com/graphql",
          "headers": {
            "Authorization": "Bearer your-token-here",
            "X-API-Key": "your-api-key-here"
          },
          "defaults": {
            "out": "pretty"
          },
          "_comment": "Default configuration - used when no specific config is active"
        },
        "production": {
          "endpoint": "https://api.company.com/graphql",
          "headers": {
            "Authorization": "Bearer prod-token-123"
          },
          "defaults": {
            "out": "json"
          }
        },
        "staging": {
          "endpoint": "https://staging-api.company.com/graphql", 
          "headers": {
            "Authorization": "Bearer staging-token-456"
          },
          "defaults": {
            "out": "pretty"
          }
        },
        "local": {
          "endpoint": "http://localhost:4000/graphql",
          "headers": {},
          "defaults": {
            "out": "pretty"
          }
        }
      },
      "_schema": {
        "endpoint": "GraphQL endpoint URL (required)",
        "headers": "HTTP headers to include with requests",
        "defaults.out": "Default output mode: json|pretty|raw"
      }
    }

[ ] 18. Example usage:
    # Initialize config file (creates default config)
    gqlt config init
    
    # AI-friendly setup
    gqlt config describe              # Show schema and examples
    gqlt config validate              # Check config validity
    gqlt config examples              # Show usage examples
    gqlt config template github       # Create GitHub API template
    gqlt config template localhost    # Create local development template
    
    # Create additional configurations
    gqlt config create production
    gqlt config set production endpoint https://api.company.com/graphql
    gqlt config set production headers.Authorization "Bearer token123"
    
    gqlt config create staging  
    gqlt config set staging endpoint https://staging-api.company.com/graphql
    
    # Switch between configs
    gqlt config use production
    gqlt run -q '{ me { name } }'  # uses production config
    
    gqlt config use staging
    gqlt run -q '{ me { name } }'  # uses staging config
    
    gqlt config use default
    gqlt run -q '{ me { name } }'  # uses default config
    
    # Override specific values
    gqlt run -q '{ me { name } }' -u https://override.com/graphql
    
    # AI-friendly debugging
    gqlt config show --format=json    # Structured output for AI parsing
    gqlt config list --format=table  # Tabular data for easy parsing
    gqlt config docs                  # Generate documentation

[ ] 19. AI-friendly features:
    - Self-documenting config structure with _schema and _comment fields
    - Rich help system with examples and suggestions
    - Validation with actionable error messages
    - Template system for common use cases
    - Structured output formats (json, table) for AI parsing
    - Auto-completion hints for commands and values
    - Context-aware error messages with solutions
    - Documentation generation for AI understanding

[ ] 20. Template examples:
    gqlt config template github        # GitHub GraphQL API
    gqlt config template localhost    # Local development
    gqlt config template production    # Production setup
    gqlt config template staging       # Staging environment
    gqlt config template apollo        # Apollo Server
    gqlt config template hasura       # Hasura GraphQL

---------------------------------------------------------------
PHASE 4 | INTROSPECTION AND DESCRIBE
---------------------------------------------------------------

[ ] 17. cmd/introspect.go
    - endpoint via flag/config
    - issue introspection query:
      query IntrospectionQuery { __schema { types { name kind fields { name type { name kind } } } } }
    - save to .gqlt/schema.json or user-specified path
    - flags:
       --refresh (ignore cache)
       --out path
       --summary (stdout short)

[ ] 18. cmd/describe.go
    - read schema JSON file
    - build index:
        map[TypeName]TypeMetadata
        map[Query|Mutation|Subscription]FieldSummary
    - arguments:
        gqlt describe Query
        gqlt describe Query.product
        gqlt describe Type.Product
    - options:
        --json  (exact node JSON)
        --summary (plain text)
    - typical output:
        TYPE Query
        ├── product(id: ID!): Product
        └── search(q: String!): [Product]

---------------------------------------------------------------
PHASE 5 | TEST AND SCHEMA DIFF
---------------------------------------------------------------

[ ] 19. cmd/test.go
    Purpose: load YAML/JSON suite of operations + expected matches
    TestSpec structure:
        - name string
        - query string or file
        - vars  map[string]interface{}
        - expect map[string]interface{}
    Execution:
        for each test:
            runGraphQL()
            validate: each expect key -> check via JSONPath or simple dotted traversal
            count passes/fails
    Exit codes: 0 all pass, 2 failures.

[ ] 20. cmd/schema_diff.go
    Inputs: two file paths
    Compare type/field maps.
    Diff struct:
       AddedTypes, RemovedTypes
       AddedFields, RemovedFields
    Output options: default text table, or --json
    Typical:
       TYPE+ Order
       FIELD- Product.oldField

---------------------------------------------------------------
PHASE 6 | AUTHENTICATION SUPPORT
---------------------------------------------------------------

[x] 30. Add simple authentication support to run command:
    -U, --username string              (basic auth username)
    -p, --password string          (basic auth password)
    Note: Bearer tokens handled via -H "Authorization: Bearer <token>"

[x] 31. Implement simple authentication:
    - Bearer: Use -H "Authorization: Bearer <token>" header
    - Basic: Custom http.RoundTripper with Authorization header
    - None: No authentication (default)

[ ] 32. Update config structure for simple auth:
    type Config struct {
        Endpoint string            `json:"endpoint"`
        Token    string            `json:"token"`
        Username string            `json:"username"`
        Password string            `json:"password"`
        Headers  map[string]string `json:"headers"`
        Defaults struct {
            Out string `json:"out"`
        } `json:"defaults"`
    }

---------------------------------------------------------------
PHASE 7 | INTERNAL UTILITIES
---------------------------------------------------------------

[ ] 34. internal/io/io.go
    Func ReadFileOrStdin(path string) (string, error)
    Func ParseJSONFile(path string, v any) error
    Func WriteJSON(path string, data any) error

[ ] 35. internal/output/output.go
    Func PrintJSON(obj any)
    Func PrintPretty(obj any)
    Func PrintRaw(data map[string]any)

[ ] 36. internal/errors
    Central error helper for consistent exit codes.

---------------------------------------------------------------
PHASE 8 | BUILD / VALIDATION
---------------------------------------------------------------

[ ] 37. Build command:
    go build -o bin/gqlt main.go
    verify binary size < 15MB static
    test: ./bin/gqlt --help

[ ] 38. Manual tests:
    ./gqlt run --url <endpoint> --query '{__typename}'
    ./gqlt run --query-file q.graphql --vars '{"id":"1"}'
    ./gqlt introspect
    ./gqlt describe Query

[ ] 39. CI / Testing:
    Write unit tests for config merge, IO helpers
    run: go test ./...

[ ] 40. Release binaries:
    for os in linux darwin windows; do GOOS=$os go build -o dist/gqlt-$os main.go; done
    checksum + tag v0.1.0

---------------------------------------------------------------
PHASE 9 | HANDLING FILE UPLOADS
---------------------------------------------------------------

[ ] 41. Support file uploads:
    -f, --file flags parsed as "name=path" (repeatable)
    -F, --files-list string (file containing list of files to upload)
    - Parse file flags into map[name]path
    - Validate file existence before attach
    - Note: File uploads require multipart/form-data implementation
    - For now, file uploads are parsed but not yet implemented

[ ] 42. Example use in shell:
    # Simple query (formatted JSON)
    gqlt run -u https://api.example.com/graphql -q '{ __typename }'
    
    # Query with variables (colored output)
    gqlt run -u https://api.example.com/graphql -Q query.graphql -v '{"id": "123"}' -O pretty
    
    # Compact output for scripting
    gqlt run -u https://api.example.com/graphql -q '{ me { name } }' -O raw | jq '.data.me.name'
    
    # With authentication
    gqlt run -u https://api.example.com/graphql -q '{ me { name } }' -H "Authorization: Bearer <token>"
    
    # File upload (when implemented)
    gqlt run -u https://api.example.com/graphql -Q upload.graphql -f file=./photo.jpg

    Output modes:
    - json: formatted JSON with indentation (default)
    - pretty: colorized formatted JSON for development
    - raw: compact unformatted JSON for scripting

---------------------------------------------------------------
PHASE 10 | EXIT CODES SUMMARY
---------------------------------------------------------------
0  success, no errors
1  system/CLI/network error
2  GraphQL response contained "errors" or test/schema diff failures

---------------------------------------------------------------
COMPLETE WHEN:
---------------------------------------------------------------
[ ] gqlt buildable single binary (Linux, macOS, Windows)
[ ] run, introspect, describe functional
[ ] supports headers, bearer tokens, file uploads
[ ] outputs consistent JSON or colorized pretty form
[ ] uses exit codes appropriately
[ ] minimal third‑party dependencies