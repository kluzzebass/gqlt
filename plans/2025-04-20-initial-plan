================================================================
IMPLEMENTATION PLAN — GraphQL CLI Tool (gqlt)
Language: Go
Goal: Minimal, composable command‑line client for running GraphQL ops

CURRENT APPROACH: Using native HTTP client instead of GraphQL libraries
- Full control over request/response handling
- Native operation name support
- Authentication via standard HTTP headers
- No external GraphQL library dependencies
- Minimal dependencies (just cobra and color)
================================================================

---------------------------------------------------------------
PHASE 1 | PROJECT INITIALIZATION
---------------------------------------------------------------

[x] 1. Initialize "gqlt"
    go mod init github.com/kluzzebass/gqlt

[x] 2. Add module dependencies
    go get github.com/spf13/cobra@latest
    go get github.com/fatih/color@latest (optional pretty output)
    Note: Using native HTTP client instead of GraphQL library for full control
    Note: Authentication handled via headers, no OAuth2 library needed

[x] 3. Base layout
    /cmd
      root.go
      run.go
      introspect.go
      describe.go
      test.go
      schema_diff.go
    /internal
      /config
      /io
      /output
    /main.go

[x] 4. main.go content:
    package main
    import "github.com/kluzzebass/gqlt/cmd"
    func main() { cmd.Execute() }

[x] 5. cmd/root.go
    Define the root Cobra command "gqlt"
    Version: 0.1.x
    PersistentFlags: (e.g. global --config)
    Example:
      var rootCmd = &cobra.Command{Use: "gqlt"}
      func Execute() { cobra.CheckErr(rootCmd.Execute()) }

---------------------------------------------------------------
PHASE 2 | RUN COMMAND (core)
---------------------------------------------------------------

Purpose: Execute GraphQL operation (query or mutation)

[x] 6. cmd/run.go
    Use: "run"
    Short: "Execute a GraphQL operation against an endpoint"

[x] 7. Define flags with short options:
    -u, --url string                 (GraphQL endpoint; required if not in config)
    -q, --query string               (inline GraphQL document)
    -Q, --query-file string          (path to .graphql file)
    -o, --operation string           (operationName)
    -v, --vars string                (JSON object)
    -V, --vars-file string           (path to JSON file)
    -H, --header key=value           (repeatable)
    -f, --file name=path             (file uploads; repeatable)
    -F, --files-list string          (file containing list of files to upload)
    -c, --config path                (optional; override default)
    -O, --out json|pretty|raw        (output mode: json=formatted, pretty=colored, raw=compact; default json)
    -U, --username string            (username for basic authentication)
    -p, --password string            (password for basic authentication)
    Note: Bearer tokens handled via -H "Authorization: Bearer <token>"

[x] 8. Input validation rules:
    - if both --query and --query-file => error
    - if neither => read full stdin as query
    - if both --vars and --vars-file => error
    - headers accumulate across occurrences
    - files accumulate across occurrences
    - if --config given, merge config values before network call

[x] 9. Implement helper resolution:

    // loadQuery: returns string
    if runFlags.query != "" return runFlags.query
    else if runFlags.queryFile != "" => read file
    else => read stdin until EOF

    // loadVars: returns map[string]interface{}
    if --vars => json.Unmarshal
    if --vars-file => read + Unmarshal
    else => empty map

    // parseHeaders: split by first '='
    result[k] = v for each --header occurrence

    // parseFiles: map[name] = path for each --file occurrence

[x] 10. Run GraphQL call using native HTTP client:
    - Build GraphQL payload with query, operationName, variables
    - Create HTTP POST request to GraphQL endpoint
    - Set Content-Type: application/json
    - Add custom headers
    - Execute request with authenticated HTTP client
    - Parse JSON response into map[string]interface{}

[x] 11. Error handling:
    if err != nil => print to stderr, exit 1
    if result["errors"] exists and non-empty => exit 2

[x] 12. Output handler:
    switch outMode:
      "json": formatted JSON with indentation (default)
      "pretty": colorized formatted JSON with syntax highlighting
      "raw": unformatted JSON (no indentation, compact)

---------------------------------------------------------------
PHASE 3 | CONFIG FILES
---------------------------------------------------------------

Config location search order:
1. --config flag
2. ./.gqlt/config.json
3. $HOME/.config/gqlt/config.json

[ ] 13. internal/config/config.go:
    type Config struct {
        Endpoint string            `json:"endpoint"`
        Headers  map[string]string `json:"headers"`
        Defaults struct {
            Out string `json:"out"`
        } `json:"defaults"`
    }

[ ] 14. Load(path):
    reads JSON, returns *Config
    if path empty => search in standard paths
    fallback = nil if not found

[ ] 15. Merge(cli *Config, cfg *Config):
    - CLI values override
    - headers merge (CLI overwrites)
    - default Out fallback from cfg if not set
    return merged *Config

[ ] 16. cmd/config.go (optional)
    subcommands:
      gqlt config show
      gqlt config set key value
      gqlt config clear
    reads/updates JSON file on disk

---------------------------------------------------------------
PHASE 4 | INTROSPECTION AND DESCRIBE
---------------------------------------------------------------

[ ] 17. cmd/introspect.go
    - endpoint via flag/config
    - issue introspection query:
      query IntrospectionQuery { __schema { types { name kind fields { name type { name kind } } } } }
    - save to .gqlt/schema.json or user-specified path
    - flags:
       --refresh (ignore cache)
       --out path
       --summary (stdout short)

[ ] 18. cmd/describe.go
    - read schema JSON file
    - build index:
        map[TypeName]TypeMetadata
        map[Query|Mutation|Subscription]FieldSummary
    - arguments:
        gqlt describe Query
        gqlt describe Query.product
        gqlt describe Type.Product
    - options:
        --json  (exact node JSON)
        --summary (plain text)
    - typical output:
        TYPE Query
        ├── product(id: ID!): Product
        └── search(q: String!): [Product]

---------------------------------------------------------------
PHASE 5 | TEST AND SCHEMA DIFF
---------------------------------------------------------------

[ ] 19. cmd/test.go
    Purpose: load YAML/JSON suite of operations + expected matches
    TestSpec structure:
        - name string
        - query string or file
        - vars  map[string]interface{}
        - expect map[string]interface{}
    Execution:
        for each test:
            runGraphQL()
            validate: each expect key -> check via JSONPath or simple dotted traversal
            count passes/fails
    Exit codes: 0 all pass, 2 failures.

[ ] 20. cmd/schema_diff.go
    Inputs: two file paths
    Compare type/field maps.
    Diff struct:
       AddedTypes, RemovedTypes
       AddedFields, RemovedFields
    Output options: default text table, or --json
    Typical:
       TYPE+ Order
       FIELD- Product.oldField

---------------------------------------------------------------
PHASE 6 | AUTHENTICATION SUPPORT
---------------------------------------------------------------

[x] 30. Add simple authentication support to run command:
    -U, --username string              (basic auth username)
    -p, --password string          (basic auth password)
    Note: Bearer tokens handled via -H "Authorization: Bearer <token>"

[x] 31. Implement simple authentication:
    - Bearer: Use -H "Authorization: Bearer <token>" header
    - Basic: Custom http.RoundTripper with Authorization header
    - None: No authentication (default)

[ ] 32. Update config structure for simple auth:
    type Config struct {
        Endpoint string            `json:"endpoint"`
        Token    string            `json:"token"`
        Username string            `json:"username"`
        Password string            `json:"password"`
        Headers  map[string]string `json:"headers"`
        Defaults struct {
            Out string `json:"out"`
        } `json:"defaults"`
    }

---------------------------------------------------------------
PHASE 7 | INTERNAL UTILITIES
---------------------------------------------------------------

[ ] 34. internal/io/io.go
    Func ReadFileOrStdin(path string) (string, error)
    Func ParseJSONFile(path string, v any) error
    Func WriteJSON(path string, data any) error

[ ] 35. internal/output/output.go
    Func PrintJSON(obj any)
    Func PrintPretty(obj any)
    Func PrintRaw(data map[string]any)

[ ] 36. internal/errors
    Central error helper for consistent exit codes.

---------------------------------------------------------------
PHASE 8 | BUILD / VALIDATION
---------------------------------------------------------------

[ ] 37. Build command:
    go build -o bin/gqlt main.go
    verify binary size < 15MB static
    test: ./bin/gqlt --help

[ ] 38. Manual tests:
    ./gqlt run --url <endpoint> --query '{__typename}'
    ./gqlt run --query-file q.graphql --vars '{"id":"1"}'
    ./gqlt introspect
    ./gqlt describe Query

[ ] 39. CI / Testing:
    Write unit tests for config merge, IO helpers
    run: go test ./...

[ ] 40. Release binaries:
    for os in linux darwin windows; do GOOS=$os go build -o dist/gqlt-$os main.go; done
    checksum + tag v0.1.0

---------------------------------------------------------------
PHASE 9 | HANDLING FILE UPLOADS
---------------------------------------------------------------

[ ] 41. Support file uploads:
    -f, --file flags parsed as "name=path" (repeatable)
    -F, --files-list string (file containing list of files to upload)
    - Parse file flags into map[name]path
    - Validate file existence before attach
    - Note: File uploads require multipart/form-data implementation
    - For now, file uploads are parsed but not yet implemented

[ ] 42. Example use in shell:
    # Simple query (formatted JSON)
    gqlt run -u https://api.example.com/graphql -q '{ __typename }'
    
    # Query with variables (colored output)
    gqlt run -u https://api.example.com/graphql -Q query.graphql -v '{"id": "123"}' -O pretty
    
    # Compact output for scripting
    gqlt run -u https://api.example.com/graphql -q '{ me { name } }' -O raw | jq '.data.me.name'
    
    # With authentication
    gqlt run -u https://api.example.com/graphql -q '{ me { name } }' -H "Authorization: Bearer <token>"
    
    # File upload (when implemented)
    gqlt run -u https://api.example.com/graphql -Q upload.graphql -f file=./photo.jpg

    Output modes:
    - json: formatted JSON with indentation (default)
    - pretty: colorized formatted JSON for development
    - raw: compact unformatted JSON for scripting

---------------------------------------------------------------
PHASE 10 | EXIT CODES SUMMARY
---------------------------------------------------------------
0  success, no errors
1  system/CLI/network error
2  GraphQL response contained "errors" or test/schema diff failures

---------------------------------------------------------------
COMPLETE WHEN:
---------------------------------------------------------------
[ ] gqlt buildable single binary (Linux, macOS, Windows)
[ ] run, introspect, describe functional
[ ] supports headers, bearer tokens, file uploads
[ ] outputs consistent JSON or colorized pretty form
[ ] uses exit codes appropriately
[ ] minimal third‑party dependencies